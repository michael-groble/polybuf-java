/*
 * Copyright (c) 2012 Michael Groble
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package polybuf.core.config;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.concurrent.atomic.AtomicReference;

import polybuf.core.proto.Polybuf;
import polybuf.core.util.Reflection;

import com.google.protobuf.Descriptors.FileDescriptor;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.GeneratedMessage;
import com.google.protobuf.GeneratedMessage.GeneratedExtension;

/**
 * Utility class for processing outer classes generated by the protobuf java compiler.
 * 
 */
public class GeneratedOuterClass {
  private final Class<?> klass;
  private final Method descriptorMethod;
  private final Method registerExtensionsMethod;
  private final AtomicReference<FileDescriptor> descriptor = new AtomicReference<FileDescriptor>(null);

  public GeneratedOuterClass(Class<?> klass) {
    this.klass = klass;
    this.descriptorMethod = Reflection.getStaticDeclaredMethodReturning(klass, "getDescriptor", FileDescriptor.class);
    this.registerExtensionsMethod = Reflection.getStaticDeclaredMethod(klass, "registerAllExtensions",
        ExtensionRegistry.class);
    assert this.descriptorMethod != null;
    assert this.registerExtensionsMethod != null;
  }

  /**
   * Apply the specified visitor to all generated messages, including nested ones.
   * @param visitor
   * @return the visitor
   */
  public <T extends GeneratedMessageVisitor> T visitGeneratedMessages(T visitor) {
    return visit(klass, visitor);
  }

  /**
   * Apply the specified visitor to all generated message extensions, including nested ones.
   * @param visitor
   * @return the visitor
   */
  public <T extends GeneratedExtensionVisitor> T visitGeneratedExtensions(T visitor) {
    return visit(klass, visitor);
  }

  private static <T extends GeneratedMessageVisitor> T visit(Class<?> root, T visitor) {
    for (Class<?> candidate : root.getDeclaredClasses()) {
      if (!GeneratedMessage.class.isAssignableFrom(candidate)) {
        continue;
      }
      visitor.visit(candidate.asSubclass(GeneratedMessage.class));
      visit(candidate, visitor);
    }
    return visitor;
  }

  private static <T extends GeneratedExtensionVisitor> T visit(Class<?> root, T visitor) {
    for (Field candidate : root.getDeclaredFields()) {
      if (GeneratedExtension.class.isAssignableFrom(candidate.getType())) {
        try {
          GeneratedExtension<?, ?> extension = (GeneratedExtension<?, ?>) candidate.get(null);
          visitor.visit(extension);
        }
        catch (Exception ex) {
          // TODO throw exception?
        }
      }
    }
    for (Class<?> candidate : root.getDeclaredClasses()) {
      if (!GeneratedMessage.class.isAssignableFrom(candidate)) {
        continue;
      }
      visit(candidate, visitor);
    }
    return visitor;
  }

  /**
   * Return the file descriptor corresponding to the generated outer class.
   */
  public FileDescriptor getFileDescriptor() {
    FileDescriptor d = descriptor.get();
    if (d == null) {
      try {
        d = (FileDescriptor) descriptorMethod.invoke(null);
        descriptor.set(d);
      }
      catch (Exception ex) {
        // should not see invocation or security issues
        assert false;
      }
    }
    return d;
  }

  /**
   * Get the annotated namespace, or {@code null} if none.
   */
  public String getAnnotatedNamespaceUri() {
    Polybuf.FileOptions options = getFileDescriptor().getOptions().getExtension(Polybuf.file);
    String uri = null;
    if (options != null && options.hasNamespaceUri()) {
      uri = options.getNamespaceUri();
    }
    return uri;
  }

  /**
   * Register all the extensions defined in this class with the specified registry.
   */
  public void registerAllExtensions(ExtensionRegistry registry) {
    try {
      registerExtensionsMethod.invoke(null, registry);
    }
    catch (Exception ex) {
      // should not see invocation or security issues
      assert false;
    }
  }
}
